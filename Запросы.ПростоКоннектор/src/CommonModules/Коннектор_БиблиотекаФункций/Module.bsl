
#Область СлужебныйПрограммныйИнтерфейс

#Область ОтправкаПолучениеСообщения

// <Описание процедуры>
//
// Параметры:
//  Сообщение  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//	
Процедура ПриЗаписиДокументовИСправочников(Источник, Отказ) Экспорт
	
	// Проверка загрузки данных
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Исключаем справочники для настройки
	МассивИсключений = Новый Массив;
	МассивИсключений.Добавить(Тип("СправочникОбъект.ПравилаВыгрузкиДаннах"));
	МассивИсключений.Добавить(Тип("СправочникОбъект.ПравилаЗагрузкиДанных"));
	
	СправочникИсключение = МассивИсключений.Найти(ТипЗнч(Источник));
	Если СправочникИсключение <> Неопределено  Тогда
		Возврат;
	КонецЕсли;
	
	ВремяНачалаЗамера = Неопределено;
	ВесЗамера = 1;
	ВерсияБСП = Коннектор_БиблиотекаФункцийПовтИсп.ВерсияБСП();
	Если ВерсияБСП <> "" Тогда
		ВремяНачалаЗамера = ОценкаПроизводительности.НачатьЗамерВремени();
	КонецЕсли;
	
	// Получаем имя объекта метаданных
	МетаданныеИсточника = Источник.Метаданные();
	ИмяМетаданных = МетаданныеИсточника.ПолноеИмя();
	
	ПравилаВыгрузки = Коннектор_БиблиотекаФункцийПовтИсп.ПравилаВыгрузки(ИмяМетаданных);
	ВесЗамера = ПравилаВыгрузки.Количество();
	
	Для каждого Правило Из ПравилаВыгрузки Цикл
		
		Попытка
		
			ТаблицаРезультат = Новый ТаблицаЗначений;
			Если Правило.ВариантВыгрузки = Перечисления.ВариантыВыгрузки.СКД
				Или Правило.ВариантПроверкиУсловияВыгрузки = Перечисления.ВариантыПроверкиУсловийВыгрузки.СКД
				Тогда
				ВыполнитьСКД(Правило, Источник.Ссылка, ТаблицаРезультат);
			КонецЕсли;
			
			Если Не ПроверитьУсловияВыгрузки(Правило, Источник, ТаблицаРезультат) Тогда
				Возврат;
			КонецЕсли;
		
			ТелоСообщения = "";
			
			Если Правило.ВариантВыгрузки = Перечисления.ВариантыВыгрузки.ИсполняемыйКод Тогда 
				
				Если ПустаяСтрока(Правило.ИсполняемыйКод) Тогда
					ЛогированиеПроцесса("ПриЗаписиДокументовИСправочников",
						УровеньЖурналаРегистрации.Предупреждение, ,
						СтрШаблон("Исполняемый код не задан. Код правила: %1", Правило.КодПравила));
					Продолжить;
				КонецЕсли;
				
				ТелоСообщения = "";
				ВыполнитьИсходящийОбработчик(Правило.ИсполняемыйКод, Источник, ТелоСообщения);
				
			ИначеЕсли Правило.ВариантВыгрузки = Перечисления.ВариантыВыгрузки.EnterpriseData Тогда
				
				Если ВерсияБСП = "" Тогда
					ЛогированиеПроцесса("ПриЗаписиДокументовИСправочников", 
						УровеньЖурналаРегистрации.Предупреждение, ,
						СтрШаблон("Отсуствует версия БСП. Код правила: %1", Правило.КодПравила));
					Продолжить;
				КонецЕсли;
				
				АдресНаСервере = ПолучитьИмяВременногоФайла("xml");
				ВыгрузитьВФорматеEnterpriseData(Правило, Источник.Ссылка, МетаданныеИсточника, АдресНаСервере);
				
				ТекстовыйДокумент = Новый ТекстовыйДокумент;
				ТекстовыйДокумент.Прочитать(АдресНаСервере);
				ТелоСообщения = ТекстовыйДокумент.ПолучитьТекст(); 
				
				УдалитьФайлы(АдресНаСервере);
				
			ИначеЕсли Правило.ВариантВыгрузки = Перечисления.ВариантыВыгрузки.КД2 Тогда
				
				АдресНаСервере = ПолучитьИмяВременногоФайла("xml");
				ВыгрузитьЧерезУниверсальныйОбмен(Правило, Источник.Ссылка, АдресНаСервере);
				
				ТекстовыйДокумент = Новый ТекстовыйДокумент;
				ТекстовыйДокумент.Прочитать(АдресНаСервере);
				ТелоСообщения = ТекстовыйДокумент.ПолучитьТекст(); 
				
				УдалитьФайлы(АдресНаСервере);
				
			ИначеЕсли Правило.ВариантВыгрузки = Перечисления.ВариантыВыгрузки.СКД Тогда
				
				ТелоСообщения = РезультатСКДСтрокойJSON(ТаблицаРезультат);
				
			ИначеЕсли Правило.ВариантВыгрузки = Перечисления.ВариантыВыгрузки.Конструктор Тогда
				
				ТелоСообщения = РезультатКонструктораСтрокойJSON(Правило, Источник);
				
			КонецЕсли;
			
			Если Константы.Коннектор_АсинхронныйОбмен.Получить() Тогда
				ЗаписатьСообщениеВОчередь(Правило, ТелоСообщения);
			Иначе	
				ОтправкаСообщения(Правило, ТелоСообщения);
			КонецЕсли;
			
		Исключение
			
			ЛогированиеПроцесса("ПриЗаписиДокументовИСправочников",
				УровеньЖурналаРегистрации.Ошибка,
				Источник.Ссылка,
				ОписаниеОшибки());
			
		КонецПопытки;
		
	КонецЦикла;
	
	Если ВерсияБСП <> "" Тогда
		ОценкаПроизводительности.ЗакончитьЗамерВремени("ОперацияПоВыгрузкеЧерезКоннектор", ВремяНачалаЗамера, ВесЗамера, "Вес по количеству правил вырузки");
	КонецЕсли;
	
КонецПроцедуры 

// <Описание процедуры>
//
// Параметры:
//  Сообщение  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//
Процедура ОбработкаВходящегоСообщения(Знач Сообщение) Экспорт
	
	Попытка
		
		ЛогированиеПроцесса("ОбработкаВходящегоСообщения", , , "Получение входящего сообщения.");
		
		ДанныеСообщения = ДанныеИзВхСообщения(Сообщение);	
		
		Если ДанныеСообщения <> "" Тогда 
			
			КодПравила = Сообщение.Параметры.Получить("КодПравила");
			Если Не ЗначениеЗаполнено(КодПравила) Тогда
				ЛогированиеПроцесса("ОбработкаВходящегоСообщения",
					УровеньЖурналаРегистрации.Предупреждение, ,
					"Не указан код правила в параметрах входящего сообщения");
				Возврат;
			КонецЕсли;
			
			МассивПравилЗагрузки = Коннектор_БиблиотекаФункцийПовтИсп.ПравилаЗагрузкиДанных(КодПравила);
			
			Для Каждого Правило Из МассивПравилЗагрузки Цикл    
							
				Если Правило.ВариантЗагрузки = Перечисления.ВариантыВыгрузки.ИсполняемыйКод Тогда
					
					Если ПустаяСтрока(Правило.ИсполняемыйКод) Тогда
						ЛогированиеПроцесса("ОбработкаВходящегоСообщения",
							УровеньЖурналаРегистрации.Предупреждение, ,
							СтрШаблон("Исполняемый код не задан. Код правила отправителя: %1", КодПравила));
						Продолжить;
					КонецЕсли;
					
					ВыполнитьВходящийОбработчик(Правило.ИсполняемыйКод, ДанныеСообщения);
					
				ИначеЕсли Правило.ВариантЗагрузки = Перечисления.ВариантыВыгрузки.EnterpriseData Тогда
					
					Если Коннектор_БиблиотекаФункцийПовтИсп.ВерсияБСП() = "" Тогда
						ЛогированиеПроцесса("ОбработкаВходящегоСообщения", 
							УровеньЖурналаРегистрации.Предупреждение, ,
							СтрШаблон("Отсуствует версия БСП. Код правила отправителя: %1", КодПравила));
						Продолжить;
					КонецЕсли;
					ЗагрузитьВФорматеEnterprisedata(ДанныеСообщения);
					
				ИначеЕсли Правило.ВариантЗагрузки = Перечисления.ВариантыВыгрузки.КД2 Тогда
					
					ЗагрузитьЧерезУниверсальныйОбмен(ДанныеСообщения);
					
				ИначеЕсли Правило.ВариантЗагрузки = Перечисления.ВариантыВыгрузки.СКД Тогда
					
					ЗагрузитьПроизвольныйСКД(ДанныеСообщения);
					
				ИначеЕсли Правило.ВариантЗагрузки = Перечисления.ВариантыВыгрузки.Конструктор Тогда
					
					ЗагрузитьПроизвольныйКонструктор(ДанныеСообщения);
					
				КонецЕсли;  
				
			КонецЦикла;

		КонецЕсли;
		
	Исключение 
		
		ЛогированиеПроцесса("ОбработкаВходящегоСообщения",
			УровеньЖурналаРегистрации.Ошибка, ,
			ОписаниеОшибки());
		
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

// <Описание функции>
//
// Параметры:
//   Значение   - Любое значение, которое необходимо преобразовать в JSON.
//
// Возвращаемое значение:
//   Строка в формате JSON.
Функция ТелоСообщенияКакJSON(Значение) Экспорт
	Попытка
		ЗаписьJSON = Новый ЗаписьJSON(); 
		ЗаписьJSON.УстановитьСтроку(); 
		// Настройки сериализации
		НастройкиСериализации = Новый НастройкиСериализацииJSON;
		НастройкиСериализации.ВариантЗаписиДаты = ВариантЗаписиДатыJSON.ЛокальнаяДата;
		НастройкиСериализации.ФорматСериализацииДаты = ФорматДатыJSON.ISO; 
		
		// Запись значения в JSON
		ЗаписатьJSON(ЗаписьJSON, Значение, НастройкиСериализации);
		
		// Возвращение строки JSON
		Возврат ЗаписьJSON.Закрыть();
		
	Исключение
		ЛогированиеПроцесса("ТелоСообщенияКакJSON",
				УровеньЖурналаРегистрации.Ошибка,
				,
				"Ошибка при преобразовании в JSON: " + ОписаниеОшибки());
	КонецПопытки;
КонецФункции

// <Описание функции>
// Параметры:
//   ТелоСообщения  - Строка  - JSON-строка, содержащая данные для преобразования.
//                              Предполагается, что строка соответствует формату JSON.
//
// Возвращаемое значение:
//   Произвольный   - Полученный из JSON-строки: структура.
//
Функция ПрочитатьТелоСообщенияJSON(Значение) Экспорт
	
    ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(Значение);
	Возврат ПрочитатьJSON(ЧтениеJSON);
	
КонецФункции 

// <Описание функции>
//
// Параметры:
//  <Параметр1>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   <Тип.Вид>   - <описание возвращаемого значения>
//
Функция ТелоСообщениеКакXML(Источник) Экспорт

	

КонецФункции

// <Описание функции>
//
// Параметры:
//   Объект       - Объект, для которого требуется получить структуру.
//   ВключаяПоля  - Строка с именами реквизитов, которые необходимо включить, разделитель ",".
//   ИсключаяПоля - Строка с именами реквизитов, которые необходимо исключить, разделитель ",".
//
// Возвращаемое значение:
//   Структура - Структура с данными объекта, включая реквизиты и табличные части.
//
Функция ПолучитьСтруктуруОбъекта(Знач Объект, ДополнительныеПараметры = Неопределено) Экспорт 
	
	// Итоговая стукртура
	Result = Новый Структура;
	// Структура для реквизитов
	Структура = Новый Структура;
		
	// Обработка стандартных реквизитов
	Для каждого Реквизит из Объект.Метаданные().СтандартныеРеквизиты Цикл
		Если ТипЗнч(Объект[Реквизит.Имя]) = Тип("Число") Или 
			ТипЗнч(Объект[Реквизит.Имя]) = Тип("Дата") Или ТипЗнч(Объект[Реквизит.Имя]) = Тип("Булево") Тогда
			Структура.Вставить(Реквизит.Имя, Объект[Реквизит.Имя]);
		иначе
			Структура.Вставить(Реквизит.Имя, Строка(Объект[Реквизит.Имя]));
		КонецЕсли;
	КонецЦикла; 
	
	// Обработка дополнительных реквизитов
	Для каждого Реквизит из Объект.Метаданные().Реквизиты Цикл
		Если ТипЗнч(Объект[Реквизит.Имя]) = Тип("Число") Или 
			ТипЗнч(Объект[Реквизит.Имя]) = Тип("Дата") Или
			ТипЗнч(Объект[Реквизит.Имя]) = Тип("Булево") Тогда
			Структура.Вставить(Реквизит.Имя, Объект[Реквизит.Имя]);
		Иначе
			Структура.Вставить(Реквизит.Имя, Строка(Объект[Реквизит.Имя]));
		КонецЕсли;
		
        // Обработка специфических типов данных
		Если  ТипЗнч(Объект[Реквизит.Имя]) = Тип("СправочникСсылка.Организации") Или
			ТипЗнч(Объект[Реквизит.Имя])  = Тип("СправочникСсылка.Контрагенты") Тогда
			Структура.Вставить(Реквизит.Имя + "ИНН", Объект[Реквизит.Имя].ИНН);
			Структура.Вставить(Реквизит.Имя + "КПП", Объект[Реквизит.Имя].КПП);
		КонецЕсли;
		Если НЕ Объект[Реквизит.Имя] = Неопределено И
			Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Объект[Реквизит.Имя])) Тогда
			Структура.Вставить(Реквизит.Имя + "Код", Объект[Реквизит.Имя].Код);
		ИначеЕсли НЕ Объект[Реквизит.Имя] = Неопределено И 
			Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Объект[Реквизит.Имя])) Тогда
			Структура.Вставить(Реквизит.Имя + "Номер", Объект[Реквизит.Имя].Номер);
		КонецЕсли;
	КонецЦикла;    
	 
	// Обработка табличных частей
	Для каждого ТабличнаяЧасть из Объект.Метаданные().ТабличныеЧасти Цикл
		ТаблизазНач = Объект[ТабличнаяЧасть.Имя].Выгрузить();
		Для Каждого Колонка Из ТаблизазНач.Колонки цикл
			Массив =  ТаблизазНач.ВыгрузитьКолонку(Колонка.Имя);
			МассивВстроку = Новый Массив;
			МассивКодНомер = Новый Массив;
			МассивАртикул = Новый Массив;
			МассивИНН = Новый Массив;
			МассивКПП = Новый Массив;
			
			Для Каждого Стр из Массив цикл
				Если ТипЗнч(Стр) = Тип("Число") Или ТипЗнч(Стр) = Тип("Дата") 
					Или ТипЗнч(Стр) = Тип("Булево") Тогда
					МассивВстроку.Добавить(Стр);
				иначе
					МассивВстроку.Добавить(Строка(Стр));
				КонецЕсли;
				Если  ТипЗнч(Стр) = Тип("СправочникСсылка.Номенклатура") Тогда
					МассивАртикул.Добавить(Стр.Артикул);
				КонецЕсли;
				Если ТипЗнч(Стр) = Тип("СправочникСсылка.Организации") Или
					ТипЗнч(Стр) = Тип("СправочникСсылка.Контрагенты") Тогда
					МассивИНН.Добавить(Стр.ИНН);
					МассивКПП.Добавить(Стр.КПП);
				КонецЕсли;
		
				Если Не Стр = Неопределено И 
					Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Стр)) Тогда
					МассивКодНомер.Добавить(Стр.Код);
				ИначеЕсли НЕ Стр = Неопределено И
					Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Стр)) Тогда
					МассивКодНомер.Добавить(Стр.Номер);
				КонецЕсли;
			КонецЦикла;    
			
			Структура.Вставить(ТабличнаяЧасть.Имя + Колонка.Имя, МассивВстроку);
			
			Если МассивАртикул.Количество() > 0 Тогда
				Структура.Вставить(ТабличнаяЧасть.Имя+Колонка.Имя + "Артикул", МассивАртикул);
			КонецЕсли;
			Если МассивКодНомер.Количество() > 0 Тогда
				Структура.Вставить(ТабличнаяЧасть.Имя + Колонка.Имя + "КодНомер", МассивКодНомер);
			КонецЕсли;
			Если МассивКПП.Количество() > 0 Тогда
				Структура.Вставить(ТабличнаяЧасть.Имя + Колонка.Имя + "КПП", МассивКодНомер);
			КонецЕсли;
			Если МассивИНН.Количество() > 0 Тогда
				Структура.Вставить(ТабличнаяЧасть.Имя + Колонка.Имя + "ИНН", МассивКодНомер);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Если ДополнительныеПараметры <> Неопределено Тогда
		Если ДополнительныеПараметры.Свойство("ВключаяПоля") И
			Не ПустаяСтрока(ДополнительныеПараметры.ВключаяПоля) Тогда
			ВключитьПоляВСтруктуру(Структура, Объект, ДополнительныеПараметры.ВключаяПоля);
		КонецЕсли; 
		
		Если ДополнительныеПараметры.Свойство("ИсключаяПоля") И 
			Не ПустаяСтрока(ДополнительныеПараметры.ИсключаяПоля) Тогда
			ИсключитьПоляИзСтруктуры(Структура, ДополнительныеПараметры.ИсключаяПоля);
		КонецЕсли; 
	КонецЕсли;
	
	ТипЗначения = ТипЗнч(Объект.Ссылка);
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗначения);
	Если Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		ObjectType = "Справочник." + Объект.Метаданные().Имя;
	ИначеЕсли Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		ObjectType = "Документ." + Объект.Метаданные().Имя;
	КонецЕсли;

	Result.Вставить("ObjectType", ObjectType);
	Result.Вставить("Body", Структура);
	Возврат Result;  
	
КонецФункции

// Определяет принадлежность объекта метаданных к ссылочному типу.
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
// Возвращаемое значение:
//   Булево - Истина, если объект ссылочного типа.
//
Функция ЭтоОбъектСсылочногоТипа(ОбъектМетаданных) Экспорт
	
	ИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	Позиция = СтрНайти(ИмяОбъектаМетаданных, ".");
	Если Позиция > 0 Тогда 
		ИмяБазовогоТипа = Лев(ИмяОбъектаМетаданных, Позиция - 1);
		Возврат ИмяБазовогоТипа = "Справочник"
			Или ИмяБазовогоТипа = "Документ"
			Или ИмяБазовогоТипа = "БизнесПроцесс"
			Или ИмяБазовогоТипа = "Задача"
			Или ИмяБазовогоТипа = "ПланСчетов"
			Или ИмяБазовогоТипа = "ПланОбмена"
			Или ИмяБазовогоТипа = "ПланВидовХарактеристик"
			Или ИмяБазовогоТипа = "ПланВидовРасчета";
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// <Описание функции>
// Возвращает имя объекта метаданных из представления.
//
// Параметры:
//   Источник (Объект) - Объект метаданных (например, справочник или документ).
//                       Используется для получения полного представления метаданных.
//
// Возвращаемое значение:
//   Строка - Имя объекта метаданных, извлеченное из полного представления.
//            Например, для "Справочник.Партнеры" будет возвращено "Партнеры".
//
Функция ПолучитьИмяМетаданных(Знач Источник) Экспорт
	
	// Получаем представление метаданных объекта
    Представление = Источник.Метаданные().Представление();

    // Извлекаем часть после точки
    Возврат Сред(Представление, СтрНайти(Представление, ".") + 1);
	
КонецФункции 

// <Описание функции>
// Извлекает имя объекта метаданных из строки полного имени.
//
// Параметры:
//   ИсточникСтрокой (Строка) - Полное имя объекта метаданных в строковом виде.
//                              Например, "Справочник.Партнеры" или "Документ.ЗаказКлиента".
//
// Возвращаемое значение:
//   Строка - Имя объекта метаданных, полученное из полного имени.
//            Например, для "Справочник.Партнеры" будет возвращено "Партнеры".
//
Функция ПолучитьИмяМетаданныхИзСтроки(Знач ИсточникСтрокой) Экспорт
	// Извлекаем часть после точки
	Возврат Сред(ИсточникСтрокой, СтрНайти(ИсточникСтрокой, ".") + 1);
КонецФункции

// <Описание процедуры>
//
// Параметры:
//  ИсполняемыйКод - Строка - Строка с кодом для выполнения.
//  Источник       - ЛюбойТип - Источник данных для обработки.
//  СтруктураОбъекта  - Структура - Структура объекта для обработки.
Процедура ВыполнитьИсходящийОбработчик(Знач ИсполняемыйКод, Знач Источник, ТелоСообщения)
		
	Выполнить(ИсполняемыйКод);
	
КонецПроцедуры

Функция ВыполнитьОбработчикВыраженияКонструктора(Знач ИсполняемыйКод, Знач Источник)
	
	Результат = Неопределено;
	
	Выполнить(ИсполняемыйКод);
	
	Возврат Результат;
	
КонецФункции

// <Описание процедуры>
//
// Параметры:
//  ИсполняемыйКод - Строка - Строка с кодом для выполнения.
//  СтруктураОбъекта  - Структура - Структура объекта для обработки.
Процедура ВыполнитьВходящийОбработчик(Знач ИсполняемыйКод, СтруктураОбъекта)

	Выполнить(ИсполняемыйКод);
	
КонецПроцедуры

// <Описание процедуры>
//
// Параметры:
//  ИсполняемыйКод - Строка - Строка с кодом для выполнения.
//  Источник       - ЛюбойТип - Источник данных для обработки.
//  Результат  	   - Булево - Результат проверки условия выгрузки.
Процедура ВыполнитьОбработчикПроверкиУсловияВыгрузки(Знач ИсполняемыйКод, Знач Источник, Результат)
	
	Выполнить(ИсполняемыйКод);
	
КонецПроцедуры

// <Описание процедуры>
//
// Параметры:
//  НастройкаБазы   - СправочникСсылка.ПравилаВыгрузкиДаннах - Настройка, содержащая параметры для отправки сообщения.
//  ТелоСообщения   - Строка                                - Текст сообщения для отправки.
//
Процедура ОтправкаСообщения(НастройкаБазы, ТелоСообщения)
	
	Попытка
		
		// Проверка активности сервера
		АктивностьСервиса = СервисыИнтеграции.Коннектор_1СШина.ПолучитьАктивность();
		Если Не АктивностьСервиса Тогда
			ЛогированиеПроцесса("ОтправкаСообщения",
				УровеньЖурналаРегистрации.Ошибка, ,
				"Сервис интеграции " + НастройкаБазы.Сервис + " неактивен.");
		    Возврат;
		КонецЕсли;		
	
		// Создание сообщения
		СообщениеОбмена = СервисыИнтеграции.Коннектор_1СШина.СоздатьСообщение();
		СообщениеОбмена.КодПолучателя = НастройкаБазы.КодПолучателя;
		ТелоКакПоток = СообщениеОбмена.ПолучитьТелоКакПоток();
		
		// Работа с телом сообщения
		Буфер = ПолучитьБуферДвоичныхДанныхИзСтроки(ТелоСообщения, "utf-8");
		ТелоКакПоток.Записать(Буфер, 0, Буфер.Размер);
		ТелоКакПоток.Закрыть();
		
		// Установка параметров сообщения и отправка
		СообщениеОбмена.Параметры.Вставить("РазмерСообщения", Буфер.Размер);
		СообщениеОбмена.Параметры.Вставить("КодПравила", НастройкаБазы.КодПравила);
		СервисыИнтеграции.Коннектор_1СШина[НастройкаБазы.КаналОтправка].ОтправитьСообщение(СообщениеОбмена); 
		
		// ++ Логирование ЛарченкоА
		РегистрацияОтправленногоСообщения(СообщениеОбмена, НастройкаБазы, ТелоСообщения);
		// -- Логирование ЛарченкоА
		
	Исключение
		
		ТекстСообщения = ОписаниеОшибки() + 
		". Не удалось сформировать сообщение для узла:" +
		НастройкаБазы.КодПолучателя;
		
		ЛогированиеПроцесса("ОтправкаСообщения",
			УровеньЖурналаРегистрации.Ошибка, ,
			ТекстСообщения);
		
	КонецПопытки;
	
КонецПроцедуры

// <Описание процедуры>
//
// Параметры:
//   Структура      - Тип: Структура
//                    Исходная структура, в которую добавляются указанные поля.
//   Объект         - Тип: Объект
//                    Объект, из которого берутся значения полей.
//   ВключаяПоля    - Тип: Строка
//                    Список полей через запятую, которые необходимо включить.
Процедура ВключитьПоляВСтруктуру(Структура, Объект, ВключаяПоля)
   // Разделяем строку на массив полей
    МассивПолей = СтрРазделить(ВключаяПоля, ",", Ложь);

    // Убираем пробелы и добавляем поля в структуру
    Для каждого Имя Из МассивПолей Цикл
        Поле = СокрЛП(Имя);
        Если ПолеСуществуетВМетаданных(Объект, Поле) Тогда
            // Добавляем значение реквизита в структуру
            Структура.Вставить(Поле, Объект[Поле]);
        КонецЕсли;
    КонецЦикла;
КонецПроцедуры

// <Описание функции>
//
// Параметры:
//   Структура      - Тип: Структура
//                    Структура, из которой удаляются указанные поля.
//   ИсключаяПоля   - Тип: Строка
//                    Список полей через запятую, которые необходимо удалить.
Процедура ИсключитьПоляИзСтруктуры(Структура, ИсключаяПоля)
    // Разделяем строку на массив полей
    МассивПолей = СтрРазделить(ИсключаяПоля, ",", Ложь);

    // Удаляем пробелы и проверяем наличие каждого поля
    Для каждого ПолеИсключение Из МассивПолей Цикл
        ПолеИсключение = СокрЛП(ПолеИсключение); 
        Если Структура.Свойство(ПолеИсключение) Тогда
            Структура.Удалить(ПолеИсключение); 
        КонецЕсли;  
    КонецЦикла;
КонецПроцедуры

// <Описание функции>
//
// Параметры:
//  Объект - Объект - Экземпляр объекта данных (например, элемент справочника, документ), 
//           для которого производится проверка.
//  Поле   - Строка - Имя поля (реквизита), которое требуется проверить в метаданных.
//
// Возвращаемое значение:
//  Булево - Истина, если указанное поле существует в метаданных объекта. Ложь, если поле отсутствует.
Функция ПолеСуществуетВМетаданных(Объект, Поле)
     // Проверка среди стандартных реквизитов
    Для каждого Реквизит Из Объект.Метаданные().СтандартныеРеквизиты Цикл
        Если Реквизит.Имя = Поле Тогда
            Возврат Истина;
        КонецЕсли;
    КонецЦикла;

    // Проверка среди дополнительных реквизитов
    Для каждого Реквизит Из Объект.Метаданные().Реквизиты Цикл
        Если Реквизит.Имя = Поле Тогда
            Возврат Истина;
        КонецЕсли;
    КонецЦикла;

    Возврат Ложь;
 КонецФункции
 
// <Описание процедуры>
//
// Обработчик регламентного задания для запуска обмена с 1С:Шина.
//
Процедура Коннектор_ЗаданиеПоОбменуСШиной() Экспорт
	 
	СервисыИнтеграции.ВыполнитьОбработку();
	 
КонецПроцедуры 
  
// <Описание функции>
//
// Параметры:
//  Сообщение - Сообщение сервиса интеграции. 
//
// Возвращаемое значение:
//  Строка - Данные полученные из сообщения.  
//
Функция ДанныеИзВхСообщения(Знач Сообщение)
	
	РазмерСообщения = Сообщение.Параметры.Получить("РазмерСообщения");
		
	Если РазмерСообщения <> Неопределено Тогда
		РазмерБуфера = Число(РазмерСообщения);
	Иначе
		РазмерБуфер = 1024;
	КонецЕсли;   
	
	ТелоСообщения = Новый БуферДвоичныхДанных(0);
	Буфер = Новый БуферДвоичныхДанных(РазмерБуфера);
	Поток = Сообщение.ПолучитьТелоКакПоток();
	
	Пока Истина Цикл
		Прочитано = Поток.Прочитать(Буфер, 0, РазмерБуфера);
		Если Прочитано > 0 Тогда
			ТелоСообщения = ТелоСообщения.Соединить(Буфер);
		КонецЕсли;
		Если Прочитано < РазмерБуфера Тогда
			Прервать;								
		КонецЕсли;
	КонецЦикла;  
	
	Возврат ПолучитьСтрокуИзБуфераДвоичныхДанных(ТелоСообщения);
	
КонецФункции

// <Описание процедуры>
//
// Параметры:
//   НастройкаПравилВыгрузки   - см. Коннектор_БиблиотекаФункцийПовтИсп.НастройкаВыгрузкиПоУмолчанию().
//	 ИсточникСсылка - ссылка на выгружаемый объект
//
Процедура ВыполнитьСКД(Знач НастройкаПравилВыгрузки, Знач ИсточникСсылка, ТаблицаРезультат)
	
	ТекстЗапроса = ТекстЗапросаПоИмениМетаданных(НастройкаПравилВыгрузки.Источник, Истина);
	
	НовыйСКД = Справочники.ПравилаВыгрузкиДаннах.ПолучитьМакет("Макет"); 
	Если ЗначениеЗаполнено(ТекстЗапроса) Тогда
		НовыйСКД.НаборыДанных.НаборДанных1.Запрос = ТекстЗапроса;
	КонецЕсли;
	
	НастройкиСКД = Неопределено;
	Если НастройкаПравилВыгрузки.НастройкиСКД <> Неопределено Тогда
		НастройкиСКД = НастройкаПравилВыгрузки.НастройкиСКД.Получить();
	КонецЕсли;
	
	Если НастройкиСКД = Неопределено Тогда
		НастройкиСКД = НовыйСКД.НастройкиПоУмолчанию; 
	КонецЕсли;      
		
	СтрПараметр = НастройкиСКД.ПараметрыДанных.Элементы.Добавить();
	СтрПараметр.Параметр = Новый ПараметрКомпоновкиДанных("ОтборПоСсылке");
	СтрПараметр.Значение = ИсточникСсылка;
	СтрПараметр.Использование = Истина; 
		
	ДанныеРасшифровкиСКД = Новый ДанныеРасшифровкиКомпоновкиДанных;
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(НовыйСКД, НастройкиСКД, ДанныеРасшифровкиСКД, ,
		Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки, ,ДанныеРасшифровкиСКД);
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений; 
	ПроцессорВывода.УстановитьОбъект(ТаблицаРезультат);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных); 
	
КонецПроцедуры    

// <Описание функции>
//
// Параметры:
//   ТекстЗапроса - Строка.
//
// Возвращаемое значение:
//   СхемаКомановкиДанных. 
//
Функция СКДПоТекстуЗапроса(ТекстЗапроса) Экспорт

	НовыйСКД = Новый СхемаКомпоновкиДанных(); 
	
	Источник = НовыйСКД.ИсточникиДанных.Добавить();
	Источник.Имя = "ИсточникДанных1";
	Источник.СтрокаСоединения = "";
	Источник.ТипИсточникаДанных = "Local";  
	
	НаборДанных = НовыйСКД.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	НаборДанных.Имя = "НаборДанных1";
	НаборДанных.Запрос = ТекстЗапроса;
	НаборДанных.ИсточникДанных = "ИсточникДанных1";
	НаборДанных.АвтоЗаполнениеДоступныхПолей = Истина;     
	
	ВыбранноеПоле = НовыйСКД.ВариантыНастроек[0].Настройки.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Использование = Истина;
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("Ссылка");  
	
	Структура = НовыйСКД.ВариантыНастроек[0].Настройки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	Структура.Использование = Истина;
	Структура.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
	Структура.Порядок.Элементы.Добавить(Тип("АвтоЭлементПорядкаКомпоновкиДанных")); 
	
	Возврат НовыйСКД;	
	
КонецФункции   

// <Описание функции>
//
// Параметры:
//   ИмяМетаданных   - Строка.
//   ОтборПоСсылке   - Ссылка на объект в БД, либо любое заполненное значение.
//
// Возвращаемое значение:
//   Булево - результат провеки условий выгрузки. 
//
Функция ТекстЗапросаПоИмениМетаданных(Знач ИмяМетаданных, Знач ОтборПоСсылке = Неопределено) Экспорт  
	
	Если ИмяМетаданных = "" Тогда
		Возврат "";
	КонецЕсли;
	
	МассивСтрок = РазложитьСтрокуВМассивПодстрок(ИмяМетаданных, ".");
	
	Если МассивСтрок[0] = "Справочник" Тогда 
		МетаданныеОбъекта = Метаданные.Справочники.Найти(МассивСтрок[1]);
	ИначеЕсли МассивСтрок[0] = "Документ" Тогда 
		МетаданныеОбъекта = Метаданные.Документы.Найти(МассивСтрок[1]);
	ИначеЕсли МассивСтрок[0] = "ПланВидовХарактеристик" Тогда 
		МетаданныеОбъекта = Метаданные.ПланыВидовХарактеристик.Найти(МассивСтрок[1]);	
	КонецЕсли;
	
	МассивСтрок = Новый Массив;     
	МассивСтрок.Добавить("ВЫБРАТЬ");
	
	ПерваяСтрока = Истина;
		
	Для Каждого Эл Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		Если ПерваяСтрока = Ложь Тогда
			МассивСтрок.Добавить(",");  
		КонецЕсли;       
		МассивСтрок.Добавить(СтрШаблон("%1ТаблицаБазы.%2 КАК %2", Символы.ПС, Эл.Имя));   
		ПерваяСтрока = Ложь;
	КонецЦикла;
	
	Для Каждого Эл Из МетаданныеОбъекта.Реквизиты Цикл  
		МассивСтрок.Добавить(",");                  
		МассивСтрок.Добавить(СтрШаблон("%1ТаблицаБазы.%2 КАК %2", Символы.ПС, Эл.Имя));
	КонецЦикла;
	
	Для Каждого Эл Из МетаданныеОбъекта.ТабличныеЧасти Цикл   
		МассивСтрок.Добавить(","); 
		МассивСтрок.Добавить(СтрШаблон("%1ТаблицаБазы.%2.(", Символы.ПС, Эл.Имя));
		
		ПерваяСтрокаТЧ = Истина;                   
		Для Каждого РеквизитТЧ Из Эл.Реквизиты Цикл      
			Если ПерваяСтрокаТЧ = Ложь Тогда
				МассивСтрок.Добавить(",");
			КонецЕсли;
			МассивСтрок.Добавить(СтрШаблон("%1%2 КАК %2", Символы.ПС, РеквизитТЧ.Имя));	
			ПерваяСтрокаТЧ = Ложь;
		КонецЦикла;           
		
		МассивСтрок.Добавить(СтрШаблон("%1) КАК %2", Символы.ПС, Эл.Имя));
	КонецЦикла;                  
	
	МассивСтрок.Добавить(СтрШаблон("%1 ИЗ %2 КАК ТаблицаБазы", Символы.ПС, ИмяМетаданных));
	
	Если ЗначениеЗаполнено(ОтборПоСсылке) Тогда
		МассивСтрок.Добавить(" ГДЕ
		| ТаблицаБазы.Ссылка = &ОтборПоСсылке");
	КонецЕсли;   
	
	ТекстЗапроса = СтрСоединить(МассивСтрок);
	
	Возврат ТекстЗапроса;
	
КонецФункции

// <Описание функции>
//
// Параметры:
//   Настройка   - см. Коннектор_БиблиотекаФункцийПовтИсп.НастройкаВыгрузкиПоУмолчанию().
//
// Возвращаемое значение:
//   Булево - результат провеки условий выгрузки. 
//
Функция ПроверитьУсловияВыгрузки(Знач НастройкаПравилВыгрузки, Знач Источник, ТаблицаРезультат)
	
	Результат = Ложь;
	
	Попытка
		
		Если НастройкаПравилВыгрузки.ВариантПроверкиУсловияВыгрузки = Перечисления.ВариантыПроверкиУсловийВыгрузки.ИсполняемыйКод Тогда
			Если СокрЛП(НастройкаПравилВыгрузки.УсловияВыгрузкиИсполныемыйКод) <> "" Тогда
				ВыполнитьОбработчикПроверкиУсловияВыгрузки(НастройкаПравилВыгрузки.УсловияВыгрузкиИсполныемыйКод, Источник, Результат);
			КонецЕсли;
			
		ИначеЕсли НастройкаПравилВыгрузки.ВариантПроверкиУсловияВыгрузки = Перечисления.ВариантыПроверкиУсловийВыгрузки.СКД
			И НастройкаПравилВыгрузки.УсловиеВыгрузкиСКДУстановлено
			Тогда
			Результат = ТаблицаРезультат.Количество() > 0;
			
		КонецЕсли;
	Исключение
		
		ЛогированиеПроцесса("ПроверитьУсловияВыгрузки", УровеньЖурналаРегистрации.Ошибка, Источник.Ссылка, ОписаниеОшибки());
		
	КонецПопытки;
		
	
	Если ТипЗнч(Результат) <> Тип("Булево") Тогда
		Результат = Ложь;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции   

// <Описание процедуры>
//
// Параметры:
//  Правило   - правило выгрузки, см Коннектор_БиблиотекаФункцийПовтИсп.НастройкаВыгрузкиПоУмолчанию()
//  СсылкаНаОбъект - ссылка на выгружамый объект
//  Метаданные - метаданные выгружаемого объекта  
//	ИмяФайлаНаСервере - имя временного файла
//
Процедура ВыгрузитьВФорматеEnterpriseData(Знач Правило, Знач СсылкаНаОбъект, Знач Метаданные, Знач ИмяФайлаНаСервере) Экспорт
	
	КомпонентыОбмена = Коннектор_БиблиотекаФункцийПовтИсп.КомпонентыОбмена("Отправка",
		Правило.ВерсияФормата,
		Правило.РасширениеФормата);
		
	// Открываем файл обмена.
	ОбменДаннымиXDTOСервер.ОткрытьФайлВыгрузки(КомпонентыОбмена, ИмяФайлаНаСервере);
		
	ПравилоОбработки = КомпонентыОбмена.ПравилаОбработкиДанных.Найти(Метаданные, "ОбъектВыборкиМетаданные");    
	
	Если ЭтоОбъектСсылочногоТипа(Метаданные) Тогда
		ОбъектДляВыгрузки = СсылкаНаОбъект.ПолучитьОбъект();
	Иначе
		ОбъектДляВыгрузки = СсылкаНаОбъект;
	КонецЕсли;  
	
	ОбменДаннымиXDTOСервер.ВыгрузкаОбъектаВыборки(КомпонентыОбмена, ОбъектДляВыгрузки, ПравилоОбработки);
		
	КомпонентыОбмена.ФайлОбмена.ЗаписатьКонецЭлемента(); // Body
	КомпонентыОбмена.ФайлОбмена.ЗаписатьКонецЭлемента(); // Message
	КомпонентыОбмена.ФайлОбмена.Закрыть();
	
	Если КомпонентыОбмена.СтрокаСообщенияОбОшибке <> "" Тогда
		ЛогированиеПроцесса("ВыгрузитьВФорматеEnterpriseData",
		УровеньЖурналаРегистрации.Ошибка,
		СсылкаНаОбъект,
		КомпонентыОбмена.СтрокаСообщенияОбОшибке);	
	КонецЕсли;      
 
КонецПроцедуры    

Процедура ЛогированиеПроцесса(
	Знач ИмяМетода = "",
	Знач УровеньЖурнала = Неопределено,
	Знач СсылкаНаОбъект = Неопределено,
	Знач ТекстКомментарий = "") Экспорт 
	
	УровеньЖурнала = ?(УровеньЖурнала = Неопределено, УровеньЖурналаРегистрации.Информация, УровеньЖурнала);
	Текст = ?(ЗначениеЗаполнено(ТекстКомментарий), ТекстКомментарий, Строка(СсылкаНаОбъект)); 
	Текст = СтрШаблон("%1(): %2", ИмяМетода, Текст);
	ЗаписьЖурналаРегистрации("Коннектор", УровеньЖурнала, , СсылкаНаОбъект, Текст); 
	
КонецПроцедуры

Процедура ЗагрузитьВФорматеEnterprisedata(Знач ДанныеСообщения)
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ДанныеСообщения);
		
	ЧтениеXML.Прочитать(); // Message
	ЧтениеXML.Прочитать(); // Header
	ЗаголовокСообщенияXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML, ФабрикаXDTO.Тип("http://www.1c.ru/SSL/Exchange/Message", "Header"));
	Если ЧтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента
		Или ЧтениеXML.ЛокальноеИмя <> "Body" Тогда
		ЛогированиеПроцесса("ЗагрузитьВФорматеEnterprisedata",
			УровеньЖурналаРегистрации.Ошибка, ,
			НСтр("ru = 'Ошибка чтения сообщения загрузки. Неверный формат сообщения.'"));
		Возврат;
	КонецЕсли;
	
	СтруктураФормата = СтрРазделить(ЗаголовокСообщенияXDTO.Format, " ", Ложь);
	
	ФорматОбмена = РазложитьФорматОбмена(СтруктураФормата[0]);
	ВерсияФорматаДляЗагрузки = ФорматОбмена.Версия;
	РасширениеФорматаДляЗагрузки = "";
	
	Если СтруктураФормата.Количество() > 0 Тогда
		РасширениеФорматаДляЗагрузки = СтруктураФормата[СтруктураФормата.ВГраница()];
	КонецЕсли;
	
	КомпонентыОбмена = Коннектор_БиблиотекаФункцийПовтИсп.КомпонентыОбмена("Получение", , , ВерсияФорматаДляЗагрузки, РасширениеФорматаДляЗагрузки);
	
	ЧтениеXML.Прочитать(); // Body
	КомпонентыОбмена.Вставить("ФайлОбмена", ЧтениеXML);
	
	УстановитьПривилегированныйРежим(Истина);
	ОбменДаннымиСлужебный.ОтключитьОбновлениеКлючейДоступа(Истина);
	Попытка
		ОбменДаннымиXDTOСервер.ПроизвестиЧтениеДанных(КомпонентыОбмена);
		ОбменДаннымиСлужебный.ОтключитьОбновлениеКлючейДоступа(Ложь);
	Исключение
		ОбменДаннымиСлужебный.ОтключитьОбновлениеКлючейДоступа(Ложь);
		ВызватьИсключение;
	КонецПопытки;
	УстановитьПривилегированныйРежим(Ложь);
	 
	ЗагруженныеОбъекты = КомпонентыОбмена.ЗагруженныеОбъекты.ВыгрузитьКолонку("СсылкаНаОбъект"); 
	Если ЗагруженныеОбъекты.Количество() Тогда
		Для Каждого Эл Из ЗагруженныеОбъекты Цикл
			ЛогированиеПроцесса("ЗагрузитьВФорматеEnterprisedata", , Эл,
			СтрШаблон("Загружен %1", Эл));	
		КонецЦикла;
	КонецЕсли;
	
	Если КомпонентыОбмена.СтрокаСообщенияОбОшибке <> "" Тогда
		ЛогированиеПроцесса("ЗагрузитьВФорматеEnterprisedata",
			УровеньЖурналаРегистрации.Ошибка, ,
			КомпонентыОбмена.СтрокаСообщенияОбОшибке);	
	КонецЕсли;
	
КонецПроцедуры    

Функция РазложитьФорматОбмена(Знач ФорматОбмена)
	
	Результат = Новый Структура("БазовыйФормат, Версия");
	
	ЭлементыФормата = СтрРазделить(ФорматОбмена, "/");
	
	Если ЭлементыФормата.Количество() = 0 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неканоническое имя формата обмена <%1>'"), ФорматОбмена);
	КонецЕсли;
	
	Результат.Версия = ЭлементыФормата[ЭлементыФормата.ВГраница()];
	
	Версии = СтрРазделить(Результат.Версия, ".");
	
	Если Версии.Количество() = 0 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неканоническое представление версии формата обмена: <%1>.'"), Результат.Версия);
	КонецЕсли;
	
	ЭлементыФормата.Удалить(ЭлементыФормата.ВГраница());
	
	Результат.БазовыйФормат = СтрСоединить(ЭлементыФормата, "/");
	
	Возврат Результат;
КонецФункции

Процедура ВыгрузитьЧерезУниверсальныйОбмен(Знач Правило, Знач ИсточникСсылка, Знач ИмяФайлаНаСервере)
	
	МассивСсылок = Новый Массив;
	МассивСсылок.Добавить(ИсточникСсылка);
	
	ВремФайлПравило = ПолучитьИмяВременногоФайла("xml");
    ДвоичныеДанные = Правило.ПравилоКонвертации.Получить();
	ДвоичныеДанные.Записать(ВремФайлПравило);
	
	Обработка = Обработки.Коннектор_УниверсальныйОбмен.Создать();
    Обработка.РежимОбмена = "Выгрузка";
    Обработка.ИмяФайлаПравилОбмена = ВремФайлПравило;
	
	Обработка.ЗагружатьДанныеВРежимеОбмена = Истина;
    Обработка.ЗаписыватьРегистрыНаборамиЗаписей = Истина;
    Обработка.ЗапоминатьЗагруженныеОбъекты = Истина;
    Обработка.ИспользоватьОтборПоДатеДляВсехОбъектов = Истина; 
	Обработка.ИспользоватьТранзакции = Ложь;  
	Обработка.НеВыводитьНикакихИнформационныхСообщенийПользователю = Истина;
	
	Обработка.ВыгружатьТолькоРазрешенные = Истина;
    Обработка.ИмяФайлаОбмена = ИмяФайлаНаСервере;
    Обработка.ЗагрузитьПравилаОбмена();
    Обработка.Параметры.Вставить("МассивСсылок", МассивСсылок);
    Обработка.ВыполнитьВыгрузку();	 
	
	УдалитьФайлы(ВремФайлПравило);
		
КонецПроцедуры

Процедура ЗагрузитьЧерезУниверсальныйОбмен(ДанныеСообщения)
	
	ВременныйФайл = ПолучитьИмяВременногоФайла("xml");  
	
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(ДанныеСообщения);
	ТекстовыйДокумент.Записать(ВременныйФайл);
	
	ОбработкаОбмена = Обработки.УниверсальныйОбменДаннымиXML.Создать();
    ОбработкаОбмена.ИмяФайлаОбмена = ВременныйФайл;
    ОбработкаОбмена.РежимОбмена = "Загрузка";
    ОбработкаОбмена.ОткрытьФайлЗагрузки(Истина);
    ОбработкаОбмена.АрхивироватьФайл = Ложь;
	
	ОбработкаОбмена.ОптимизированнаяЗаписьОбъектов = Истина;     
	ОбработкаОбмена.ЗагружатьДанныеВРежимеОбмена = Истина; 
	ОбработкаОбмена.ЗаписыватьВИнформационнуюБазуТолькоИзмененныеОбъекты = Истина;   
	ОбработкаОбмена.ЗаписыватьРегистрыНаборамиЗаписей = Истина;             
	ОбработкаОбмена.ОбъектыПоСсылкеЗагружатьБезПометкиУдаления = Истина;
	
    ОбработкаОбмена.ВыполнитьЗагрузку();
    ОбработкаОбмена = Неопределено;
	
	УдалитьФайлы(ВременныйФайл);
	
КонецПроцедуры

 // Разбивает строку на несколько строк по указанному разделителю. Разделитель может иметь любую длину.
// В случаях, когда разделителем является строка из одного символа, и не используется параметр СокращатьНепечатаемыеСимволы,
// рекомендуется использовать функцию платформы СтрРазделить.
//
// Параметры:
//  Значение               - Строка - текст с разделителями.
//  Разделитель            - Строка - разделитель строк текста, минимум 1 символ.
//  ПропускатьПустыеСтроки - Булево - признак необходимости включения в результат пустых строк.
//    Если параметр не задан, то функция работает в режиме совместимости со своей предыдущей версией:
//     > для разделителя-пробела пустые строки не включаются в результат, для остальных разделителей пустые строки
//       включаются в результат;
//     > если параметр Строка не содержит значащих символов или не содержит ни одного символа (пустая строка), то в
//       случае разделителя-пробела результатом функции будет массив, содержащий одно значение "" (пустая строка), а
//       при других разделителях результатом функции будет пустой массив.
//  СокращатьНепечатаемыеСимволы - Булево - сокращать непечатаемые символы по краям каждой из найденных подстрок.
//
// Возвращаемое значение:
//  Массив из Строка
//
// Пример:
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(",один,,два,", ",")
//  - возвратит массив из 5 элементов, три из которых  - пустые: "", "один", "", "два", "";
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(",один,,два,", ",", Истина)
//  - возвратит массив из двух элементов: "один", "два";
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(" один   два  ", " ")
//  - возвратит массив из двух элементов: "один", "два";
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("")
//  - возвратит пустой массив;
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("",,Ложь)
//  - возвратит массив с одним элементом: ""(пустая строка);
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("", " ")
//  - возвратит массив с одним элементом: "" (пустая строка).
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Значение, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено, 
	СокращатьНепечатаемыеСимволы = Ложь) Экспорт
	
	Если СтрДлина(Разделитель) = 1 
		И ПропускатьПустыеСтроки = Неопределено 
		И СокращатьНепечатаемыеСимволы Тогда 
		
		Результат = СтрРазделить(Значение, Разделитель, Ложь);
		Для Индекс = 0 По Результат.ВГраница() Цикл
			Результат[Индекс] = СокрЛП(Результат[Индекс])
		КонецЦикла;
		Возврат Результат;
		
	КонецЕсли;
	
	Результат = Новый Массив;
	
	// Для обеспечения обратной совместимости.
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Значение) Тогда 
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = СтрНайти(Значение, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Значение, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Если СокращатьНепечатаемыеСимволы Тогда
				Результат.Добавить(СокрЛП(Подстрока));
			Иначе
				Результат.Добавить(Подстрока);
			КонецЕсли;
		КонецЕсли;
		Значение = Сред(Значение, Позиция + СтрДлина(Разделитель));
		Позиция = СтрНайти(Значение, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Значение) Тогда
		Если СокращатьНепечатаемыеСимволы Тогда
			Результат.Добавить(СокрЛП(Значение));
		Иначе
			Результат.Добавить(Значение);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Копирует элементы из одной коллекции в другую
//
// Параметры:
//	ПриемникЗначения	- коллекция элементов КД, куда копируются параметры
//	ИсточникЗначения	- коллекция элементов КД, откуда копируются параметры
//	ОчищатьПриемник		- признак необходимости очистки приемника (Булево, по умолчанию: истина)
//
Процедура СкопироватьЭлементы(ПриемникЗначения, ИсточникЗначения, ОчищатьПриемник = Истина) Экспорт
	
	Если ТипЗнч(ИсточникЗначения) = Тип("УсловноеОформлениеКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ВариантыПользовательскогоПоляВыборКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ОформляемыеПоляКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ЗначенияПараметровДанныхКомпоновкиДанных") Тогда
		СоздаватьПоТипу = Ложь;
	Иначе
		СоздаватьПоТипу = Истина;
	КонецЕсли;
	ПриемникЭлементов = ПриемникЗначения.Элементы;
	ИсточникЭлементов = ИсточникЗначения.Элементы;
	Если ОчищатьПриемник Тогда
		ПриемникЭлементов.Очистить();
	КонецЕсли;
	
	Для каждого ЭлементИсточник Из ИсточникЭлементов Цикл
		
		Если ТипЗнч(ЭлементИсточник) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда
			// Элементы порядка добавляем в начало
			Индекс = ИсточникЭлементов.Индекс(ЭлементИсточник);
			ЭлементПриемник = ПриемникЭлементов.Вставить(Индекс, ТипЗнч(ЭлементИсточник));
		Иначе
			Если СоздаватьПоТипу Тогда
				ЭлементПриемник = ПриемникЭлементов.Добавить(ТипЗнч(ЭлементИсточник));
			Иначе
				ЭлементПриемник = ПриемникЭлементов.Добавить();
			КонецЕсли;
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(ЭлементПриемник, ЭлементИсточник);
		// В некоторых коллекциях необходимо заполнить другие коллекции
		Если ТипЗнч(ИсточникЭлементов) = Тип("КоллекцияЭлементовУсловногоОформленияКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Поля, ЭлементИсточник.Поля);
			СкопироватьЭлементы(ЭлементПриемник.Отбор, ЭлементИсточник.Отбор);
			ЗаполнитьЭлементы(ЭлементПриемник.Оформление, ЭлементИсточник.Оформление); 
		ИначеЕсли ТипЗнч(ИсточникЭлементов)	= Тип("КоллекцияВариантовПользовательскогоПоляВыборКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Отбор, ЭлементИсточник.Отбор);
		КонецЕсли;
		
		// В некоторых элементах коллекции необходимо заполнить другие коллекции
		Если ТипЗнч(ЭлементИсточник) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник, ЭлементИсточник);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник, ЭлементИсточник);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип("ПользовательскоеПолеВыборКомпоновкиДанных")
			    И ТипЗнч(ЭлементПриемник) = Тип("ПользовательскоеПолеВыборКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Варианты, ЭлементИсточник.Варианты);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип("ПользовательскоеПолеВыражениеКомпоновкиДанных") Тогда
			ЭлементПриемник.УстановитьВыражениеДетальныхЗаписей (ЭлементИсточник.ПолучитьВыражениеДетальныхЗаписей());
			ЭлементПриемник.УстановитьВыражениеИтоговыхЗаписей(ЭлементИсточник.ПолучитьВыражениеИтоговыхЗаписей());
			ЭлементПриемник.УстановитьПредставлениеВыраженияДетальныхЗаписей(ЭлементИсточник.ПолучитьПредставлениеВыраженияДетальныхЗаписей ());
			ЭлементПриемник.УстановитьПредставлениеВыраженияИтоговыхЗаписей(ЭлементИсточник.ПолучитьПредставлениеВыраженияИтоговыхЗаписей ());
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры  

// Заполняет одну коллекцию элементов на основании другой
//
// Параметры:
//	ПриемникЗначения	- коллекция элементов КД, куда копируются параметры
//	ИсточникЗначения	- коллекция элементов КД, откуда копируются параметры
//	ПервыйУровень		- уровень структуры коллекции элементов КД для копирования параметров
//
Процедура ЗаполнитьЭлементы(ПриемникЗначения, ИсточникЗначения, ПервыйУровень = Неопределено) Экспорт
	
	Если ТипЗнч(ПриемникЗначения) = Тип("КоллекцияЗначенийПараметровКомпоновкиДанных") Тогда
		КоллекцияЗначений = ИсточникЗначения;
	Иначе
		КоллекцияЗначений = ИсточникЗначения.Элементы;
	КонецЕсли;
	
	Для каждого ЭлементИсточник Из КоллекцияЗначений Цикл
		Если ПервыйУровень = Неопределено Тогда
			ЭлементПриемник = ПриемникЗначения.НайтиЗначениеПараметра(ЭлементИсточник.Параметр);
		Иначе
			ЭлементПриемник = ПервыйУровень.НайтиЗначениеПараметра(ЭлементИсточник.Параметр);
		КонецЕсли;
		Если ЭлементПриемник = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(ЭлементПриемник, ЭлементИсточник);
		Если ТипЗнч(ЭлементИсточник) = Тип("ЗначениеПараметраКомпоновкиДанных") Тогда
			Если ЭлементИсточник.ЗначенияВложенныхПараметров.Количество() <> 0 Тогда
				ЗаполнитьЭлементы(ЭлементПриемник.ЗначенияВложенныхПараметров, ЭлементИсточник.ЗначенияВложенныхПараметров, ПриемникЗначения);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция РезультатСКДСтрокойJSON(Знач ТаблицаРезультат)

	Ответ = Новый Массив;
	
	Для Каждого Строка Из ТаблицаРезультат Цикл
		
		СтруктураСтрока = Новый Структура;
		
		Для Каждого Колонка Из ТаблицаРезультат.Колонки Цикл
			
			ЗначениеЯчейки = Строка[Колонка.Имя];
			Если Не ЗначениеЗаполнено(ЗначениеЯчейки) Тогда 
				ЗначениеЯчейки = Неопределено;
			КонецЕсли;
			
			ДобавитьЗначениеВСтруктуруВыгрузки(СтруктураСтрока, Колонка.Имя, ЗначениеЯчейки)
			
		КонецЦикла;
		
		Ответ.Добавить(СтруктураСтрока);
		
	КонецЦикла;
	
	Возврат ТелоСообщенияКакJSON(Ответ);
	
КонецФункции

Функция РезультатКонструктораСтрокойJSON(Правило, Источник)
	
	//Ответ = Новый Массив;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Коннектор_СвойстваКонструктора.Родитель КАК Родитель,
		|	Коннектор_СвойстваКонструктора.Ссылка КАК Ссылка,
		|	Коннектор_СвойстваКонструктора.Наименование КАК Наименование,
		|	Коннектор_СвойстваКонструктора.ВариантПравилЗаполненияСвойства КАК ВариантПравилЗаполненияСвойства,
		|	Коннектор_СвойстваКонструктора.РеквизитИС КАК РеквизитИС,
		|	Коннектор_СвойстваКонструктора.ВыражениеНаВстроенномЯзыке КАК ВыражениеНаВстроенномЯзыке,
		|	Коннектор_СвойстваКонструктора.Владелец КАК Владелец,
		|	Коннектор_СвойстваКонструктора.ЭтоМассив КАК ЭтоМассив,
		|	Коннектор_СвойстваКонструктора.Родитель.Наименование КАК РодительНаименование
		|ИЗ
		|	Справочник.Коннектор_СвойстваКонструктора КАК Коннектор_СвойстваКонструктора
		|ГДЕ
		|	Коннектор_СвойстваКонструктора.Владелец = &Правило
		|	И НЕ Коннектор_СвойстваКонструктора.ПометкаУдаления
		|	И НЕ Коннектор_СвойстваКонструктора.ВариантПравилЗаполненияСвойства = &НеЗаполнять
		|
		|УПОРЯДОЧИТЬ ПО
		|	Родитель
		|ИТОГИ ПО
		|	Родитель ИЕРАРХИЯ";
	
	Запрос.УстановитьПараметр("Правило", Правило.ПравилоСсылка);
	Запрос.УстановитьПараметр("НеЗаполнять", Перечисления.Коннектор_ВариантыПравилЗаполненияСвойствКонструктора.НеЗаполнять);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Выборка = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
	
	СтруктураОтвета = Новый Структура;
	СтруктураПараметров = Новый Структура;
	
	СтруктураПараметров.Вставить("РеквизитОбъекта", Перечисления.Коннектор_ВариантыПравилЗаполненияСвойствКонструктора.РеквизитОбъекта);
	СтруктураПараметров.Вставить("Выражение", Перечисления.Коннектор_ВариантыПравилЗаполненияСвойствКонструктора.ВыражениеНаВстроенномЯзыке);
	СтруктураПараметров.Вставить("ИсточникСсылка", Источник.Ссылка);
	СтруктураПараметров.Вставить("Правило", Правило.ПравилоСсылка);
	
	ОбходВложенийЗапросаКонструктора(Выборка, СтруктураОтвета, СтруктураПараметров);
	
	//Ответ.Добавить(СтруктураОтвета);
	
	Возврат ТелоСообщенияКакJSON(СтруктураОтвета);
	
КонецФункции

Процедура ЗагрузитьПроизвольныйСКД(Знач СтрокаJSON)
	
	Данные = ПрочитатьТелоСообщенияJSON(СтрокаJSON); 
	
	Для Каждого Эл Из Данные Цикл
		
		ОбъектСсылки = Неопределено;
		СтруктураСсылки = Неопределено;
		
		Если Эл.Свойство("Ссылка", СтруктураСсылки) Тогда
			
			Ссылка = Неопределено;
			Менеджер = МенеджерОбъектаПоПолномуИмени(СтруктураСсылки.ИмяМетаданного); 
			Ссылка = ПолучитьСсылку(Менеджер, СтруктураСсылки.Значение);
			
			Если СсылкаСуществует(Ссылка) Тогда
				
				ОбъектСсылки = Ссылка.ПолучитьОбъект();
				ОбъектСсылки.Заблокировать();
				
			Иначе	               
				
				Если СтрНайти(СтруктураСсылки.ИмяМетаданного, "Документ.") <> 0 Тогда
					ОбъектСсылки = Менеджер.СоздатьДокумент();
				ИначеЕсли СтрНайти(СтруктураСсылки.ИмяМетаданного, "Справочник.") <> 0
					Или СтрНайти(СтруктураСсылки.ИмяМетаданного, "ПланВидовХарактеристик.") <> 0
					Тогда
					ОбъектСсылки = Менеджер.СоздатьЭлемент();
					ОбъектСсылки.УстановитьСсылкуНового(Ссылка);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
		Для Каждого Поле Из Эл Цикл
			Если Поле.Ключ <> "Ссылка" Тогда	
				
				Если ТипЗнч(Поле.Значение) <> Тип("Структура") Тогда
					ОбъектСсылки[Поле.Ключ] = Поле.Значение;
				Иначе
					Менеджер = МенеджерОбъектаПоПолномуИмени(Поле.Значение.ИмяМетаданного); 
					ОбъектСсылки[Поле.Ключ] = ПолучитьСсылку(Менеджер, Поле.Значение.Значение);	
				КонецЕсли;
				
			КонецЕсли;
		КонецЦикла;  
		
		Если ОбъектСсылки <> Неопределено Тогда
			ОбъектСсылки.Записать();
		КонецЕсли;
		
	КонецЦикла;		
	
КонецПроцедуры  

Процедура ЗагрузитьПроизвольныйКонструктор(ДанныеСообщения)
	
	//В разработке
	
КонецПроцедуры

Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	Перем КлассОМ, ИмяОМ, Менеджер;
	
	ЧастиИмени = СтрРазделить(ПолноеИмя, ".");
	
	Если ЧастиИмени.Количество() >= 2 Тогда
		КлассОМ = ЧастиИмени[0];
		ИмяОМ   = ЧастиИмени[1];
	Иначе 
		Менеджер = Неопределено;
	КонецЕсли;
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Менеджер = ПланыОбмена;
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Менеджер = Справочники;
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Менеджер = Документы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Менеджер = ЖурналыДокументов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Менеджер = Перечисления;
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Менеджер = Отчеты;
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Менеджер = Обработки;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Менеджер = ПланыВидовХарактеристик;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Менеджер = ПланыСчетов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Менеджер = ПланыВидовРасчета;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Менеджер = РегистрыСведений;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Менеджер = РегистрыНакопления;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Менеджер = РегистрыБухгалтерии;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		
		Если      ЧастиИмени.Количество() = 2 Тогда
			Менеджер = РегистрыРасчета;
			
		ИначеЕсли ЧастиИмени.Количество() = 4 Тогда
			КлассПодчиненногоОМ = ЧастиИмени[2];
			ИмяПодчиненногоОМ = ЧастиИмени[3];
			
			Если ВРег(КлассПодчиненногоОМ) = "ПЕРЕРАСЧЕТ" Тогда 
				Менеджер = РегистрыРасчета[ИмяОМ].Перерасчеты;
				ИмяОм = ИмяПодчиненногоОМ;
				
			Иначе 
				Менеджер = Неопределено;
			КонецЕсли;
			
		Иначе
			Менеджер = Неопределено;
		КонецЕсли;
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Менеджер = БизнесПроцессы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Менеджер = Задачи;
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Менеджер = Константы;
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Менеджер = Последовательности;
		
	Иначе
		Менеджер = Неопределено;
	КонецЕсли;
	
	Попытка
		Возврат Менеджер[ИмяОМ];
	Исключение
		ВызватьИсключение;
	КонецПопытки;
	
КонецФункции

// Заполняет перечень доступных к выгрузке объектов метаданных в соответствии с компонентами обмена.
Функция ЗаполнениеПравилВыгрузки(ВерсияФормата, РасширениеФормата) Экспорт
	
	ТаблицаПравилВыгрузки = Новый ДеревоЗначений; 
	ТаблицаПравилВыгрузки.Колонки.Добавить("Выбрать", Новый ОписаниеТипов("Булево"));
	ТаблицаПравилВыгрузки.Колонки.Добавить("ЭтоГруппа", Новый ОписаниеТипов("Булево"));
	ТаблицаПравилВыгрузки.Колонки.Добавить("Наименование", Новый ОписаниеТипов("Строка"));
	ТаблицаПравилВыгрузки.Колонки.Добавить("ПолноеИмяМетаданных", Новый ОписаниеТипов("Строка"));
	ТаблицаПравилВыгрузки.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка"));
	
	КомпонентыОбмена = Коннектор_БиблиотекаФункцийПовтИсп.КомпонентыОбмена("Отправка", ВерсияФормата, РасширениеФормата);
	ТаблицаПравилВыгрузки.Строки.Очистить();
	УзелДереваСправочники = ТаблицаПравилВыгрузки.Строки.Добавить();
	УзелДереваСправочники.ЭтоГруппа = Истина;
	УзелДереваСправочники.Наименование = НСтр("ru = 'Справочники'");
	
	УзелДереваДокументы = ТаблицаПравилВыгрузки.Строки.Добавить();
	УзелДереваДокументы.ЭтоГруппа = Истина;
	УзелДереваДокументы.Наименование = НСтр("ru = 'Документы'");
	//УзелДереваДокументы.ОтборПоПериоду = Истина;

	УзелДереваПВХ = ТаблицаПравилВыгрузки.Строки.Добавить();
	УзелДереваПВХ.ЭтоГруппа = Истина;
	УзелДереваПВХ.Наименование = НСтр("ru = 'Планы видов характеристик'");
	
	Для Каждого СтрокаПОД Из КомпонентыОбмена.ПравилаОбработкиДанных Цикл
		
		ТекМД = СтрокаПОД.ОбъектВыборкиМетаданные;
		Если ТекМД = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ТекИмя = ТекМД.Имя;
		ТекСиноним = ТекМД.Синоним;
		ПолноеИмяМДСтрокой = "";
		НовСтрока = Неопределено;
		Если Метаданные.Справочники.Содержит(ТекМД) Тогда
			НовСтрока = УзелДереваСправочники.Строки.Добавить();
			ПолноеИмяМДСтрокой = "Справочник." + ТекИмя;
			Представление = НСтр("ru = 'Справочник %1'");
		ИначеЕсли Метаданные.Документы.Содержит(ТекМД) Тогда
			НовСтрока = УзелДереваДокументы.Строки.Добавить();
			//НовСтрока.ОтборПоПериоду = Истина;
			ПолноеИмяМДСтрокой = "Документ." + ТекИмя;
			Представление = НСтр("ru = 'Документ %1'");
		ИначеЕсли  Метаданные.ПланыВидовХарактеристик.Содержит(ТекМД) Тогда
			НовСтрока = УзелДереваПВХ.Строки.Добавить();
			ПолноеИмяМДСтрокой = "ПланВидовХарактеристик." + ТекИмя;
			Представление = НСтр("ru = 'План видов характеристик %1'");
		Иначе
			// Выгрузка других объектов метаданных не поддерживается.
			Продолжить;
		КонецЕсли;
		Представление = СтрЗаменить(Представление, "%1", ТекСиноним);
		НовСтрока.ЭтоГруппа = Ложь;
		НовСтрока.Наименование = ТекСиноним;
		НовСтрока.ПолноеИмяМетаданных = ПолноеИмяМДСтрокой;
		НовСтрока.Представление = Представление;
	КонецЦикла;
	
	// Удалим лишние ветки
	Если УзелДереваСправочники.Строки.Количество() = 0 Тогда
		ТаблицаПравилВыгрузки.Строки.Удалить(УзелДереваСправочники);
	КонецЕсли;
	Если УзелДереваДокументы.Строки.Количество() = 0 Тогда
		ТаблицаПравилВыгрузки.Строки.Удалить(УзелДереваДокументы);
	КонецЕсли;
	Если УзелДереваПВХ.Строки.Количество() = 0 Тогда
		ТаблицаПравилВыгрузки.Строки.Удалить(УзелДереваПВХ);
	КонецЕсли; 
	
	Возврат ТаблицаПравилВыгрузки;
	
КонецФункции

// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки.
//
// Параметры:
//  ПроверяемаяСсылка - ЛюбаяСсылка - значение любой ссылки информационной базы данных.
// 
// Возвращаемое значение:
//  Булево - Истина, если существует.
//
Функция СсылкаСуществует(ПроверяемаяСсылка) Экспорт
	
	ТекстЗапроса = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	1 КАК Поле1
		|ИЗ
		|	&ИмяТаблицы КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяТаблицы", ИмяТаблицыПоСсылке(ПроверяемаяСсылка));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ПроверяемаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Возвращает полное имя объекта метаданных по переданному значению ссылки.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, для которого необходимо получить имя таблицы ИБ.
// 
// Возвращаемое значение:
//  Строка - полное имя объекта метаданных для указанного объекта. Например: "Справочник.Номенклатура".
//
Функция ИмяТаблицыПоСсылке(Ссылка) Экспорт
	
	Возврат Ссылка.Метаданные().ПолноеИмя();
	
КонецФункции

Функция ПолучитьСсылку(Менеджер, СтрокаГуид)
	
	Возврат Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(СтрокаГуид))
	
КонецФункции

// Описание
Процедура РегистрацияОтправленногоСообщения(Знач СообщениеОбмена, Знач НастройкаБазы, Знач ТелоСообщения)
	МенеджерЗаписи = РегистрыСведений.Коннектор_РегистрацияЗапросов.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Период = СообщениеОбмена.ДатаОтправки;
	МенеджерЗаписи.Канал = НастройкаБазы.КаналОтправка;
	МенеджерЗаписи.Источник = НастройкаБазы.Источник;
	МенеджерЗаписи.Направление = Перечисления.Направление.Выгрузка;
	МенеджерЗаписи.Идентификатор = СообщениеОбмена.Идентификатор;
	МенеджерЗаписи.ДатаУстаревания = СообщениеОбмена.ДатаУстаревания;
	МенеджерЗаписи.Отправлено = Истина;
	МенеджерЗаписи.КодПравила = НастройкаБазы.КодПравила;
	МенеджерЗаписи.КодПолучателя = НастройкаБазы.КодПолучателя;
	МенеджерЗаписи.ТелоСообщения = ТелоСообщения; 
	МенеджерЗаписи.Записать(); 
	
	ТекстСообщения = "Формирование сообщений шины." + Символы.ПС + СообщениеОбмена.Идентификатор
	+ Символы.ПС + ТелоСообщения;
	
	ЗаписьЖурналаРегистрации("ОтправкаСообщения",
	УровеньЖурналаРегистрации.Информация,
	Метаданные.РегистрыСведений.Коннектор_РегистрацияЗапросов, ,
	ТекстСообщения);
КонецПроцедуры	

// Записывает сообщение в очередь, для последующей отправки
//
// Параметры:
//  НастройкаБазы   - СправочникСсылка.ПравилаВыгрузкиДаннах - Настройка, содержащая параметры для отправки сообщения.
//  ТелоСообщения   - Строка                                - Текст сообщения для отправки.
//
Процедура ЗаписатьСообщениеВОчередь(НастройкаБазы, ТелоСообщения)
	МенеджерЗаписи = РегистрыСведений.Коннектор_ОчередьНаОтправку.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Период = ТекущаяДатаСеанса();
	МенеджерЗаписи.Идентификатор = Строка(Новый УникальныйИдентификатор);
	МенеджерЗаписи.НастройкаБазы = Новый ХранилищеЗначения(НастройкаБазы);
	МенеджерЗаписи.ТелоСообщения = ТелоСообщения;
	МенеджерЗаписи.Записать();
КонецПроцедуры

// Возвращает структуру из параметров формы.
// 
// Параметры:
//  ПараметрыФормы - ДанныеФормыСтруктура
// 
// Возвращаемое значение:
//  Структура
Функция СтруктураИзПараметровФормы(Знач ПараметрыФормы) Экспорт
	
	Результат = Новый Структура;
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, ПараметрыФормы, НазначениеТипаXML.Явное);
	СтрокаXML = ЗаписьXML.Закрыть();
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Пока ЧтениеXML.Прочитать() Цикл
		
		Если ЧтениеXML.Имя = "structure" 
			И ЧтениеXML.ПолучитьАтрибут("name") = "parameters" 
			И ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			
			Прервать;
			             
		ИначеЕсли ЧтениеXML.Имя = "field" Тогда
			
			ТекущийКлюч	= ЧтениеXML.ПолучитьАтрибут("nameRu");
			ТекущийКлюч	= ?(ЗначениеЗаполнено(ТекущийКлюч), ТекущийКлюч, ЧтениеXML.ПолучитьАтрибут("name")); 
			Если СтрНайти(ТекущийКлюч, ".") > 0 Тогда
				Продолжить;
			КонецЕсли;	
			Если ЗначениеЗаполнено(ТекущийКлюч) Тогда
				Результат.Вставить(ТекущийКлюч);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ЧтениеXML.Закрыть();
	
	ЗаполнитьЗначенияСвойств(Результат, ПараметрыФормы);
	
	Возврат Результат;
	
КонецФункции

Процедура ОбработкаОчередиОтправкиВШину() Экспорт
	Если Не Константы.Коннектор_АсинхронныйОбмен.Получить() Тогда
		Возврат;
	КонецЕсли; 
	
	ЧислоПотоков = Константы.Коннектор_ЧислоПотоков.Получить();
	Если ЧислоПотоков = 0 Тогда
		Возврат;
	КонецЕсли;	
	
	Запрос = Новый Запрос();
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Коннектор_ОчередьНаОтправку.Идентификатор КАК Идентификатор,
		|	Коннектор_ОчередьНаОтправку.НастройкаБазы КАК НастройкаБазы,
		|	Коннектор_ОчередьНаОтправку.ТелоСообщения КАК ТелоСообщения,
		|	Коннектор_ОчередьНаОтправку.Период КАК Период
		|ИЗ
		|	РегистрСведений.Коннектор_ОчередьНаОтправку КАК Коннектор_ОчередьНаОтправку
		|ГДЕ
		|	Коннектор_ОчередьНаОтправку.ДатаОтправки = ДАТАВРЕМЯ(1, 1, 1)";
	ТаблицаСообщений = Запрос.Выполнить().Выгрузить();
	
	Если ТаблицаСообщений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;	
	
	ЧислоСтрокВТаблице = ТаблицаСообщений.Количество();
	РазмерПорции = Цел(ЧислоСтрокВТаблице / ЧислоПотоков);
	
	Для НомерПотока = 1 По ЧислоПотоков Цикл  
		ИндексНачала = (НомерПотока - 1) * РазмерПорции;
		
		Если (НомерПотока = ЧислоПотоков) Тогда
			// если это последний поток, то он обрабатывает все оставшиеся данные
			РазмерПорции = ЧислоСтрокВТаблице - (ЧислоПотоков * РазмерПорции) + РазмерПорции;
		КонецЕсли;
		
		НаборПараметров = Новый Массив;
		НаборПараметров.Добавить(ТаблицаСообщений);
		НаборПараметров.Добавить(ИндексНачала);
		НаборПараметров.Добавить(РазмерПорции); 
		
		Задание = ФоновыеЗадания.Выполнить("Коннектор_БиблиотекаФункций.ОбработатьОтправкуСообщения", НаборПараметров);
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбработатьОтправкуСообщения(ТаблицаСообщений, ИндексНачала, РазмерПорции) Экспорт

	Запись = РегистрыСведений.Коннектор_ОчередьНаОтправку.СоздатьМенеджерЗаписи();
	Для Счетчик = 1 По РазмерПорции Цикл
		Индекс = ?(Счетчик = 1, ИндексНачала, Индекс + 1);
		СтрокаТаблицы = ТаблицаСообщений.Получить(Индекс);
		
		Запись.Период = СтрокаТаблицы.Период;
		Запись.Идентификатор = СтрокаТаблицы.Идентификатор;
		Запись.Прочитать(); 
		
		Если Запись.Выбран() Тогда 
			НастройкаБазы = СтрокаТаблицы.НастройкаБазы.Получить();
			Если ТипЗнч(НастройкаБазы) = Тип("Структура") Тогда
				ОтправкаСообщения(НастройкаБазы, СтрокаТаблицы.ТелоСообщения);
			Иначе
				Продолжить;
			КонецЕсли;	
			Запись.ДатаОтправки = ТекущаяДатаСеанса();
			Запись.Записать();
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры	

Процедура ДобавитьЗначениеВСтруктуруВыгрузки(Структура, Ключ, Значение)
	
	Если ТипЗнч(Значение) = Тип("Строка")
		Или ТипЗнч(Значение) = Тип("Число")
		Или ТипЗнч(Значение) = Тип("Булево")
		Или ТипЗнч(Значение) = Тип("Дата")
		Или Значение = Неопределено
		Тогда
		Структура.Вставить(Ключ, Значение); 
	Иначе	
		Тип = ТипЗнч(Значение);
		ИмяОбъектаМетаданного = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
		Структура.Вставить(Ключ, Новый Структура("ИмяМетаданного, Значение", ИмяОбъектаМетаданного, XMLСтрока(Значение)));
	КонецЕсли;

КонецПроцедуры

Функция ПреобразоватьЗначениеВJSON(ЗначениеДляПреобразования)
	
	Если ТипЗнч(ЗначениеДляПреобразования) = Тип("Строка")
		Или ТипЗнч(ЗначениеДляПреобразования) = Тип("Число")
		Или ТипЗнч(ЗначениеДляПреобразования) = Тип("Булево")
		Или ТипЗнч(ЗначениеДляПреобразования) = Тип("Дата")
		Или ТипЗнч(ЗначениеДляПреобразования) = Тип("Массив")
		Или ЗначениеДляПреобразования = Неопределено
		Тогда
		
		ЗначениеПреобразованное = ЗначениеДляПреобразования;
		
	Иначе
		
		ЗначениеПреобразованное = Строка(ЗначениеДляПреобразования);
		
	КонецЕсли;
	
	Возврат ЗначениеПреобразованное;
	
КонецФункции

Процедура ОбходВложенийЗапросаКонструктора(Выборка, СтруктураОтвета, СтруктураПараметров)
	
	СпособВыборки = ОбходРезультатаЗапроса.ПоГруппировкамСИерархией;
	Пока Выборка.Следующий() Цикл
		
		Если Выборка.ТипЗаписи() = ТипЗаписиЗапроса.ДетальнаяЗапись Тогда
			ЗначениеСвойства = Неопределено;
			Если Выборка.ВариантПравилЗаполненияСвойства = СтруктураПараметров.РеквизитОбъекта Тогда
				ЗначениеСвойства = ЗначениеРеквизитаОбъекта(СтруктураПараметров.ИсточникСсылка, Выборка.РеквизитИС);
			ИначеЕсли Выборка.ВариантПравилЗаполненияСвойства = СтруктураПараметров.Выражение Тогда
				СтруктураПараметров.Вставить("СвойствоКонструктора", Выборка.Наименование);
				ЗначениеСвойства = ВыполнитьВыражениеКонструктора(
					Выборка.ВыражениеНаВстроенномЯзыке, 
					СтруктураПараметров, 
					Выборка.ЭтоМассив);
			КонецЕсли;
			
			СтруктураОтвета.Вставить(Выборка.Наименование, ПреобразоватьЗначениеВJSON(ЗначениеСвойства));
			
		Иначе
			Если Выборка.ТипЗаписи() = ТипЗаписиЗапроса.ИтогПоГруппировке Тогда
				ДочерняяВыборка = Выборка.Выбрать(СпособВыборки);
				Если Выборка.Родитель.Пустая() Тогда
					ОбходВложенийЗапросаКонструктора(ДочерняяВыборка, СтруктураОтвета, СтруктураПараметров);
				Иначе
					СтруктураОтветаРодитель = Новый Структура;
					ОбходВложенийЗапросаКонструктора(ДочерняяВыборка, СтруктураОтветаРодитель, СтруктураПараметров);
					СтруктураОтвета.Вставить(Выборка.РодительНаименование, СтруктураОтветаРодитель);
				КонецЕсли;
			ИначеЕсли Выборка.ТипЗаписи() = ТипЗаписиЗапроса.ИтогПоИерархии Тогда
				ДочерняяВыборка = Выборка.Выбрать(СпособВыборки, Выборка.Группировка());
				ОбходВложенийЗапросаКонструктора(ДочерняяВыборка, СтруктураОтвета, СтруктураПараметров);
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура УстановитьОтборСпискаСвойствКонструктора(Список, ИмяПоля, ПравоеЗначение = Неопределено) Экспорт
	
	// Не используем БСП, т.к. в конфигурация может быть без БСП
	ЭлементОтбора = Список.КомпоновщикНастроек.ФиксированныеНастройки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
	ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ЭлементОтбора.ПравоеЗначение = ПравоеЗначение;
	
КонецПроцедуры

Процедура ДобавитьЗначенияМассиваКонструктора(МассивРеквизитов, Источник, МассивЗначений)
	
	СтруктураЗначенийМассива = Новый Структура;
	ДобавитьРеквизитыВСтруктуруВыгрузки(МассивРеквизитов, Источник, СтруктураЗначенийМассива);
	МассивЗначений.Добавить(СтруктураЗначенийМассива);
	
КонецПроцедуры

Процедура ДобавитьВМассивРезультатВыборки(МассивРезультат, СтрокаВыражения)
	
	Если Не ПустаяСтрока(СтрокаВыражения) Тогда
		МассивРезультат.Добавить(СтрокаВыражения);
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьРеквизитыВСтруктуруВыгрузки(МассивРеквизитов, Источник, СтруктураОтвета)
	
	СписокРеквизитовСтрокой = СтрСоединить(МассивРеквизитов, ", ");
	Если ПустаяСтрока(СписокРеквизитовСтрокой) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураЗначений = ЗначенияРеквизитовОбъекта(Источник, СписокРеквизитовСтрокой);
	
	Для Каждого ЭлементСтруктуры Из СтруктураЗначений Цикл
		ДобавитьЗначениеВСтруктуруВыгрузки(СтруктураОтвета, ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
	КонецЦикла;
	
КонецПроцедуры

Функция ВыполнитьВыражениеКонструктора(ИсполняемыйКод, СтруктураПараметров, ЭтоМассив = Ложь)
	
	РезультатОтвет = Новый Массив;
	
	Если ЭтоМассив Тогда
		// получим массив
		РезультатОтвет = МассивИзВыраженияКонструктора(ИсполняемыйКод, СтруктураПараметров);
	Иначе
		РезультатОтвет = ВыполнитьОбработчикВыраженияКонструктора(ИсполняемыйКод, СтруктураПараметров.ИсточникСсылка);
	КонецЕсли;
	
	Возврат РезультатОтвет;
	
КонецФункции

Функция МассивИзВыраженияКонструктора(ИсполняемыйКод, СтруктураПараметров)
	
	МассивОтвет = Новый Массив;
	
	ТаблицаЗначений = ВыполнитьОбработчикВыраженияКонструктора(ИсполняемыйКод, СтруктураПараметров.ИсточникСсылка);
	
	Если ТипЗнч(ТаблицаЗначений) <> Тип("ТаблицаЗначений") Тогда
		ТекстОшибки = СтрШаблон("Результат выражения вернул результат не равный таблице значений,
		|Правило: %1
		|Свойство: %2",
		СтруктураПараметров.Правило,
		СтруктураПараметров.СвойствоКонструктора);
		ЛогированиеПроцесса("МассивИзВыраженияКонструктора",
				УровеньЖурналаРегистрации.Ошибка,
				СтруктураПараметров.ИсточникСсылка,
				ТекстОшибки);
		Возврат МассивОтвет;
	КонецЕсли;
	
	МассивИмен = Новый Массив;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		МассивИмен.Добавить(Колонка.Имя);
	КонецЦикла;
	
	ИменаКлючей = СтрСоединить(МассивИмен, ", ");
	
	Для Каждого СтрокаТаблицы Из ТаблицаЗначений Цикл
		СтруктураОтвета = Новый Структура(ИменаКлючей);
		Для Каждого ИмяКолонки Из МассивИмен Цикл
			СтруктураОтвета.Вставить(ИмяКолонки, ПреобразоватьЗначениеВJSON(СтрокаТаблицы[ИмяКолонки]));
		КонецЦикла;
		МассивОтвет.Добавить(СтруктураОтвета);
	КонецЦикла;
	
	Возврат МассивОтвет;
	
КонецФункции

Функция ЗначениеРеквизитаОбъекта(Объект, РеквизитСтрокой)
	
	ЗначенияРеквизитов = ЗначенияРеквизитовОбъекта(Объект, РеквизитСтрокой);
	
	Возврат ЗначенияРеквизитов[СтрЗаменить(РеквизитСтрокой, ".", "")];
	
КонецФункции

Функция ЗначенияРеквизитовОбъекта(Объект, СписокРеквизитовСтрокой)
	
	// Получаем имя объекта метаданных
	МетаданныеИсточника = Объект.Метаданные();
	ИмяМетаданных = МетаданныеИсточника.ПолноеИмя();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	#Реквизиты
		|ИЗ
		|	#Таблица
		|ГДЕ
		|	Ссылка = &Ссылка";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "#Таблица", ИмяМетаданных);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "#Реквизиты", СписокРеквизитовСтрокой);
	Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
	РезультатЗапроса = Запрос.Выполнить();
	
	Выборка = РезультатЗапроса.Выбрать();

	СтруктураЗначений = Новый Структура(СтрЗаменить(СписокРеквизитовСтрокой, ".", ""));
	Пока Выборка.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(СтруктураЗначений, Выборка);
	КонецЦикла;
		
	Возврат СтруктураЗначений;
	
КонецФункции

#КонецОбласти 
 
 
